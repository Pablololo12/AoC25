(define-module (days day04)
  #:export (run)
  #:use-module (srfi srfi-1))

(define maxx 0)
(define maxy 0)

(define (coordinate-list x y)
  (let loop ((i 0)
             (out '()))
    (if (= i x)
        (reverse out)
        (let loop2 ((j 0)
                    (acc out))
          (if (= j y)
              (loop (+ i 1) acc)
              (loop2 (+ j 1)
                     (cons (cons i j) acc)))))))

(define (check-neigh coord in)
  (let* ((neigh
          (list (cons -1 0) (cons 1 0) (cons 0 1) (cons 0 -1)
            (cons 1 1) (cons 1 -1) (cons -1 1) (cons -1 -1)))
         (getn (lambda (x y) (cons (+ (car x) (car y)) (+ (cdr x) (cdr y)))))
         (valid (lambda (x)
                  (let ((i (car x))
                        (j (cdr x)))
                    (if (or (< i 0) (< j 0) (= i maxx) (= j maxy)) #f #t))))
         (chk (lambda (x) (if (valid x) (list-ref (list-ref in (cdr x)) (car x)) 0))))
    (if (= (list-ref (list-ref in (cdr coord)) (car coord)) 1)
        (if (< (apply + (map (lambda (x) (chk (getn coord x))) neigh)) 4) 1 0)
        0)))

(define (part1 input)
  (let ((itlist (coordinate-list maxx maxy)))
    (apply + (map (lambda (x) (check-neigh x input)) itlist))))

(define (get-new-map in)
    (map (lambda (y) (map (lambda (x) (check-neigh (cons x y) in)) (iota maxx))) (iota maxy)))

(define (iter input)
  (let ((new-map (get-new-map input)))
    (map (lambda (yi yj) (map (lambda (xi  xj) (if (= xi xj) 0 xi)) yi yj)) input new-map)))

(define (count input)
  (apply + (map (lambda (x) (apply + x)) input)))

(define (part2 input)
  (let loop ((prev (count input))
             (new (iter input)))
    (if (= prev (count new))
        (- (count input) prev)
        (loop (count new) (iter new)))))

(define (run input)
  (let ((in (map (lambda (x) (map (lambda (y) (if (char=? y #\@) 1 0)) (string->list x))) input)))
    (set! maxx (length (car in)))
    (set! maxy (length in))
    (format #t "Part1: ~a~%Part2: ~a~%" (part1 in) (part2 in))))
